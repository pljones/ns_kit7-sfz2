desc: TD-27 Hi-hat Splash detector OMNI (pljones)
author: Peter L Jones
version: 2.0
about: Detects direction changes in CC4 and emits a configurable "hi-hat splash" note. Passes through CC4 but blocks incoming splash note number.
source: https://raw.githubusercontent.com/pljones/ns_kit7-sfz2/refs/heads/main/_td-27kv2_scripts/jsfx/TD-27_hihat_splash.jsfx

slider1:chickNote=44<0,127,1>Hi-hat chick Note to watch
slider2:splashNote=97<0,127,1>Hi-hat splash MIDI note to emit
slider3:closedSide=1<0,1,1{Keyboard (CC4 0=closed),eKit (CC4 127=closed)}>Hi-hat type
slider4:splashTime=50<1,500,1>Splash detection window (ms)
slider5:velScale=2.5<0,10,0.1>Splash velocity scaling factor
slider6:dbgCC4Value=0<0,127,1>(dbg) CC4 value
slider7:dbgBlockCtr=0<0,47999,1>Block count
slider8:dbgNoteAt=-1<-1,47999,1>Block count plus offset when Chick seen
slider9:dbgSplashVel=0<0,127,1>Splash Velocity

in_pin:none
out_pin:none

@init
need_note_off = 0;     // explicit note off trigger
note_ch = -1;          // capture on chick note
chick_cc4 = -1;        // capture last cc4 on chick note
note_at = -1;          // block count (0) plus offset when chick note seen 
current_cc4 = 64;      // current position (set to mid point... randomly...)
last_cc4 = 64;         // last seen position (set to mid point... randomly...)
cc4_seen_at = -1;      // block count plus offset when cc4 first seen
last_cc4_at = -1;      // block count plus offset when cc4 last seen

// Tracking vars for pedal motion analysis
state = 0;                  // 0=pre-close, 1=closing, 2=resting, 3=opening, 4=done
close_start_at = 0;         // When closing phase started
close_end_at = 0;           // When closing phase ended (entering rest)
rest_end_at = 0;            // When rest phase ended (entering open)
open_start_at = 0;          // When opening phase started
open_end_at = 0;            // When opening phase ended (splash)
close_cc4_delta = 0;        // CC4 change during close
open_cc4_delta = 0;         // CC4 change during open
close_time_ms = 0;          // Time spent closing
rest_time_ms = 0;           // Time spent at rest
open_time_ms = 0;           // Time spent opening




function get_direction(oldCC4, currentCC4) (
  (oldCC4 == -1) || (currentCC4 == -1) || (oldCC4 == currentCC4) ? (
    0
  ) : (closedSide == 0) ? (
    (oldCC4 < currentCC4) ? 1 : -1
  ) : (
    (oldCC4 > currentCC4) ? -1 : 1
  )
);

function is_opening (
  get_direction(last_cc4, current_cc4) == 1 ? 1 : 0;
);

function is_closing (
  get_direction(last_cc4, current_cc4) == -1 ? 1 : 0;
);

function is_closed (
  get_direction(chick_cc4, current_cc4) == -1 ? 1 : 0;
);

function is_open (
  get_direction(chick_cc4, current_cc4) == 1 ? 1 : 0
);

function get_cc4_delta (
  is_opening() ? (
    closedSide == 0 ? (
      current_cc4 - last_cc4
    ) : (
      last_cc4 - current_cc4
    )
  ) : (
    0
  )
);


@block
(note_at != -1) && (dbgBlockCtr < 48000) ? (
  dbgBlockCtr = dbgBlockCtr + samplesblock;
) : (
  // time out
  note_ch = -1;
  note_at = -1;
  dbgBlockCtr = 0;
);

need_note_off ? (
  // we sent a splash - now send a noteOff for it
  midisend(0, ($x80 | note_ch) & $xFF, splashNote & $x7F, $x40);
  need_note_off = 0;
  state = 0;
  close_cc4_delta = 0;
  open_cc4_delta = 0;
  close_time_ms = 0;
  rest_time_ms = 0;
  open_time_ms = 0;
);

// Process incoming MIDI messages - TD-27 is not very accurate to clock - offset is useless
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & $xF0;
  ch = msg1 & $x0F;

  // Drop any incoming messages that match the splash note (regardless of channel)
  ((status == $x90) || (status == $x80)) && (msg2 == splashNote) ? (
    // drop incoming splash note
    0;
  ) : (
    // pass everything else through
    midisend(offset, msg1, msg2, msg3);

    (status == $x90) && (msg2 == chickNote) && (msg3 > 0) ? (
      note_at = offset;
      dbgNoteAt = note_at;
      note_ch = ch;
      chick_cc4 = last_cc4;
    );
  );

  need_note_off ? (
    // we sent a splash (maybe more than one this block..?) - now send a noteOff for it
    midisend(offset, ($x80 | note_ch) & $xFF, splashNote & $x7F, $x40);
    need_note_off = 0;
    state = 0;
    close_cc4_delta = 0;
    open_cc4_delta = 0;
    close_time_ms = 0;
    rest_time_ms = 0;
    open_time_ms = 0;
  );

  // if CC4 on same channel as chick note
  (status == $xB0) && (msg2 == $x04) && (ch == note_ch) ? (
    last_cc4 = current_cc4;
    current_cc4 = msg3;
    dbgCC4Value = current_cc4;
    
    cc4_seen_at = dbgBlockCtr + offset;

    // State machine for pedal motion
    (state == 0) && is_closing() ? (
      // Pedal started closing after chick
      state = 1;
      close_start_at = cc4_seen_at;
      close_cc4_delta = get_closing_delta(); // You'll need this function

    ) : (state == 1) && is_closed() ? (
      // Pedal fully closed, now resting
      state = 2;
      close_end_at = cc4_seen_at;
      close_time_ms = (close_end_at - close_start_at) * 1000 / srate;
      close_cc4_delta = get_closing_delta();

    ) : (state == 2) && is_opening() ? (
      // Pedal started opening after resting closed
      state = 3;
      rest_end_at = cc4_seen_at;
      rest_time_ms = (rest_end_at - close_end_at) * 1000 / srate;
      open_start_at = cc4_seen_at;

    ) : (state == 3) && is_open() ? (
      // Pedal opening - check if splash
      state = 4;
      open_end_at = cc4_seen_at;
      open_time_ms = (open_end_at - open_start_at) * 1000 / srate;
      open_cc4_delta = get_cc4_delta();
      
      // Use the motion analysis for splash detection
      (rest_time_ms > 0) && (rest_time_ms <= splashTime) ? (
        // Proper splash: closed, rested, then opened
        splash_vel = min(127, (close_cc4_delta + open_cc4_delta) * velScale);
        dbgSplashVel = splash_vel;
        // Send splash...
        midisend(offset, ($x90 | note_ch) & $xFF, splashNote & $x7F, splash_vel & $x7F);
        need_note_off = 1;
      );
    );

    last_cc4 = current_cc4;
    last_cc4_at = cc4_seen_at;
  );

);

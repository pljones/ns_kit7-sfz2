desc: TD-27 Hi-hat Splash detector (pljones)
author: Peter L Jones
version: 3.0
about: Uses speed of change in direction of CC4 across a reported Chick note to substitute a Splash note (introduces configurable latency)
source: https://raw.githubusercontent.com/pljones/ns_kit7-sfz2/refs/heads/main/_td-27kv2_scripts/jsfx/TD-27_hihat_splash.jsfx

slider1:chickNote=44<0,127,1>Hi-hat chick MIDI note to watch (sets channel and velocity)
slider2:splashNote=97<0,127,1>Hi-hat splash MIDI note to emit (uses channel and velocity)
slider3:closedSide=1<0,1,1{Keyboard (CC4 0=closed),eKit (CC4 127=closed)}>Hi-hat type
slider4:splashTime=12<1,100,0.1>Splash detection window (ms)
slider5:pedalThreshold=4<0,63,1>Pedal sensitivity (reduces false triggers, etc)
slider6:dbgCC4Value=0<0,127,1>(dbg) CC4 value
slider7:dbgTimer=0<0,1000,1>(dbg) Timer

in_pin:none
out_pin:none

@init
// Returns the difference (disregarding pedal closure side) between CC4 values
function subtract_cc4(more_open, less_open) (
  closedSide == 0 ? (more_open - less_open) : (less_open - more_open)
);

// True if first value more open than second value
function is_more_open(cc4_a, cc4_b) (
  subtract_cc4(cc4_a, cc4_b) > 0
);

// True if first value more open than second value by third value or more
function is_more_open_by(cc4_a, cc4_b, threshold) (
  subtract_cc4(cc4_a, cc4_b) > threshold
);

// True if first value more closed than second value
function is_more_closed(cc4_a, cc4_b) (
  subtract_cc4(cc4_a, cc4_b) < 0
);

// True if current values (if available) shows an opening movement (false if insufficient values or not opening)
// (Currently unused)
function is_opening() (
  (last_cc4 == -1) || (current_cc4 == -1) ? 0 : is_more_open(current_cc4, last_cc4)
);

// True if current values (if available) shows a closing movement (false if insufficient values or not closing)
function is_closing() (
  (last_cc4 == -1) || (current_cc4 == -1) ? 0 : is_more_closed(current_cc4, last_cc4)
);

// Current timestamp in milliseconds
function now_ms(offset) (
  ((sample_pos + offset) * 1000) / srate
);

// Has the current time reached the timer?
function timer_expired(offset) (
  expiry_time == -1 ? 0 : (expiry_time - now_ms(offset)) <= 0
);

function reset_timer() (
  state = 0;
  sample_pos = 0;
  dbgTimer = sample_pos;
  expiry_time = -1;
  last_cc4_at = -1;
);

// If we sent a note on, send a note off for it
function maybe_send_note_off(offset) (
  (need_note_off != -1) ? (
    midisend(offset, ($x80 | note_ch) & $xFF, need_note_off & $x7F, $x40);
    need_note_off = -1;
  );
);

// Check if we need to send a note on
function maybe_send_note_on(offset) (
  (state == 3) && timer_expired(offset) ? (
    // If current_cc4 is more open than chick_cc4 send splash else send chick
    is_more_open_by(current_cc4, chick_cc4, pedalThreshold) ? (
      midisend(offset, ($x90 | note_ch) & $xFF, splashNote & $x7F, note_vel & $x7F);
      need_note_off = splashNote;
    ) : (
      midisend(offset, ($x90 | note_ch) & $xFF, chickNote & $x7F, note_vel & $x7F);
      need_note_off = chickNote;
    );
    reset_timer();
  );
);

function maybe_reset_timer(offset) (
  timer_expired(offset) ? reset_timer();
);

// Tracking vars
state = 0;             // 0 - idle; 1 & 2 - tracking pedal down; 3 - tracking pedal up
sample_pos = 0;        // Accumulated sample position (used to calculate time)
expiry_time = -1;      // When tracking, the timer expiry time
last_cc4_at = -1;      // Require at least one CC4 before the chick position CC4

current_cc4 = 64;      // Latest CC4 value (set to mid point... randomly...)
last_cc4 = 64;         // Previous CC4 value (set to mid point... randomly...)
chick_cc4 = -1;        // CC4 value at chick note moment
need_note_off = -1;    // Indicates the note off to be sent when not -1
note_vel = 0;          // Velocity for splash note on
note_ch = 0;           // Channel captured on chick note


// state:
// Any:
//   - if a note off is required, send it (maybe_send_note_off)
//   - on timer expiry (maybe_reset_timer, after maybe_send_note_on)
//     - clear the timer and reset state
//   - on CC4: after everything else, set last_cc4 to current_cc4, store last_cc4_at
// 0 - "Idle": waiting for CC4
//     - pass through all events
//     - on CC4:
//       - if pedal closing (i.e. at least one CC4 has passed), set state to 1
// 1, 2: - "Pedal closing": wait for chick
//     - state 1: pass through all events
//     - state 2:
//       - ignore splash and chick note events, pass through all others
//       - on chick:
//         - store CC4 and note details
//         - reset timer expiry (last_cc4_at + splashTime) and restart timer
//         - set state to 3
//     - on CC4, either state:
//       - if closing enough: set state to 2, set timer expiry (last_cc4_at + splashTime) and start timer
// 3 - "Waiting for timer":
//     - pass through all events
//     - on timer expiry (maybe_send_note_on):
//       - check the pedal position relative to the chick position
//         - if sufficiently more open, send a splash note
//         - else send a chick note
//         - require a note off for the relevant note on
//       - clear the timer and reset state
//     - no additional CC4 handling

@block
state > 1 ? (
  sample_pos = sample_pos + samplesblock;
  dbgTimer = sample_pos;
);

maybe_send_note_off(0);
maybe_send_note_on(0);
maybe_reset_timer(0);

// Process incoming MIDI messages - TD-27 is not very accurate to clock - offset is useless
while (midirecv(offset, msg1, msg2, msg3)) (
  status = msg1 & $xF0;
  ch = msg1 & $x0F;

  //- stick with once per block for now -//
  //maybe_send_note_off(offset);
  //maybe_send_note_on(offset);
  //maybe_reset_timer(offset);

  // If tracking pedal down, ignore (do "nothing") splash or chick note events and pass everything else through
  (state == 2) && ((status == $x90) || (status == $x80)) && ((msg2 == splashNote) || (msg2 == chickNote)) ? (
    0; // Do nothing in a JSFX-friendly way
  ) : (
    midisend(offset, msg1, msg2, msg3); // Send the current event
  );

  // Did the pedal close fast enough?
  (state == 2) && (status == $x90) && (msg2 == chickNote) && (msg3 > 0) ? (
    chick_cc4 = current_cc4;  // So we know when the pedal opens
    note_ch = ch;             // Capture the channel the chick happened on for everything else
    note_vel = msg3;          // Velocity for chick or splash

    sample_pos = offset;                       // set timer
    expiry_time = now_ms(offset) + splashTime; // set expiry
    state = 3;                                 // start the timer
  );

  // CC4 handler
  (status == $xB0) && (msg2 == $x04) && (ch == note_ch) ? (
    current_cc4 = msg3;
    dbgCC4Value = current_cc4;

    (state == 0) ? (
      // Idle
      is_closing() ? (
        // Start tracking closing pedal
        state = 1;                    // wait for next CC4
      );
    ) : ((state == 1) || (state == 2)) ? (
      // Waiting for chick
      is_closing() ? (
        // Moving towards closed, keep tracking pedal
        state = 2;                              // (re)start the timer
        sample_pos = offset;                    // set timer
        dbgTimer = sample_pos; // Reset UI
        expiry_time = last_cc4_at + splashTime; // (re)set chick expiry
      ) : (
        // If moving significantly towards open, wait for next downwards movement
        is_more_open_by(current_cc4, last_cc4, pedalThreshold) ? (
          current_cc4 = last_cc4; // Pedal has "not moved"
          reset_timer();
        );
      );
    ) : (
      // This checks state and timer, cleaning up state if needed
      maybe_send_note_on(offset);
    );

    last_cc4 = current_cc4;
    last_cc4_at = now_ms(offset); // set expiry for next CC4
  );
);

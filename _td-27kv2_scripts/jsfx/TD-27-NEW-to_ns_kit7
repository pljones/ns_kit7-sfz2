desc:MIDI Map TD-27 input to ns_kit7 layout (take 2) (pljones)

// Whilst care is taken to use the incoming channel number,
// no attempt is made to allow for multiple channels in use:
// use separate tracks.

in_pin:none
out_pin:none

slider1:crash1=2<0,7,1{cy8_splash,cy9_splash,cy12_splash,cy15_crash,cy18_crash,cy19_china,cy20_ride,cy19_ride}>Crash 1 Assign
slider2:crash2=4<0,7,1{cy8_splash,cy9_splash,cy12_splash,cy15_crash,cy18_crash,cy19_china,cy20_ride,cy19_ride}>Crash 2 Assign
slider3:ride=7<0,7,1{cy8_splash,cy9_splash,cy12_splash,cy15_crash,cy18_crash,cy19_china,cy20_ride,cy19_ride}>Ride Assign
slider4:tom1=0<0,4,1{tm8,tm10,tm12,tm14,tm16}>Tom 1 Assign
slider5:tom2=2<0,4,1{tm8,tm10,tm12,tm14,tm16}>Tom 2 Assign
slider6:tom3=4<0,4,1{tm8,tm10,tm12,tm14,tm16}>Tom 3 Assign

// Treat as separate triggers
slider7:aux1head=4<0,7,1{cowbell muted ord,cowbell muted top,cowbell open ord,cowbell open top,tambourine hit,tambourine jng,tambourine rol,tambourine thm}>Aux 1 Head Assign
slider8:aux1rim=5<0,7,1{cowbell muted ord,cowbell muted top,cowbell open ord,cowbell open top,tambourine hit,tambourine jng,tambourine rol,tambourine thm}>Aux 1 Rim Assign
slider9:aux2head=2<0,7,1{cowbell muted ord,cowbell muted top,cowbell open ord,cowbell open top,tambourine hit,tambourine jng,tambourine rol,tambourine thm}>Aux 2 Head Assign
slider10:aux2rim=3<0,7,1{cowbell muted ord,cowbell muted top,cowbell open ord,cowbell open top,tambourine hit,tambourine jng,tambourine rol,tambourine thm}>Aux 2 Rim Assign
slider11:aux3head=0<0,7,1{cowbell muted ord,cowbell muted top,cowbell open ord,cowbell open top,tambourine hit,tambourine jng,tambourine rol,tambourine thm}>Aux 3 Head Assign
slider12:aux3rim=1<0,7,1{cowbell muted ord,cowbell muted top,cowbell open ord,cowbell open top,tambourine hit,tambourine jng,tambourine rol,tambourine thm}>Aux 3 Rim Assign

slider13:brushKit=0<0,1,1{off,on}>Brush Kit Mode

slider14:dgbSnareVal=0<0,127,1>snareCCVal
slider15:dgbRideVal=0<0,127,1>rideCCVal
slider16:dgbTomAuxVal=0<0,127,1>tomAuxCCVal
slider17:dgbHihatVal=0<0,127,1>hihatCCVal
slider18:dgbHihatLRVal=0<0,127,1>hihatLRCCVal
slider19:dgbHiresVelVal=0<0,127,1>hiresVelCCVal

slider20:dgbNoteOffNote=0<0,127,1>noteOff note (msg2)
slider21:dgbNoteOffVal=0<0,127,1>noteOff val (msg3)
slider22:dgbNoteOnNote=0<0,127,1>Note On note (msg2)
slider23:dgbNoteOnVal=0<0,127,1>Note On val (msg3)
slider24:dbgMappedNote=-1<-1,127,1>noteMap[msg2]
slider25:dgbPolyAftNote=0<0,127,1>polyAft note (msg2)
slider26:dgbPolyAftVal=0<0,127,1>polyAft val (msg3)

slider27:dgbPassthru=0<0,1,1{off,on}>passthru
slider28:dbgBlocksSinceLastSnareNote=0<0,1,1>blocksSinceLastSnareNote


@init
ext_noinit=1.0;

nextFree = 0;
function malloc(val, size) (
  ptr = nextFree;
  nextFree += size;
  memset(ptr, val, size);
  ptr;
);

// TD-27 default trigger note assignments
// --------------------------------------
// The DAW will need to map incoming MIDI notes to the triggers for the kit.
// The default note assignments in the module are:
//
noteKick           = 36;
noteSnareHead      = 38;
noteSnareRim       = 40;
noteSnareBrush     = 23;
noteSnareXStick    = 37;
noteTom1Head       = 48;
noteTom1Rim        = 50;
noteTom2Head       = 45;
noteTom2Rim        = 47;
noteTom3Head       = 43;
noteTom3Rim        = 58;
noteHiHatOpenBow   = 46;
noteHiHatOpenEdge  = 26;
noteHiHatCloseBow  = 42;
noteHiHatCloseEdge = 22;
noteHiHatPedal     = 44;
noteHiHatSplash    = 97;  // undocumented splash? seems to work
noteCrash1Bow      = 49;
noteCrash1Edge     = 55;
noteCrash2Bow      = 57;
noteCrash2Edge     = 52;
noteRideBow        = 51;
noteRideEdge       = 59;
noteRideBell       = 53;
noteAux1Head       = 27;
noteAux1Rim        = 28;
noteAux2Head       = 29;
noteAux2Rim        = 30;
noteAux3Head       = 31;
noteAux3Rim        = 32;


// TD-27 default CC assignments
// ----------------------------
//
hhPedalCC  =  4;
snareCC    = 16;
rideCC     = 17;
tomAuxCC   = 18;
hihatCC    = 19;
gp5CC      = 80;
gp6CC      = 81;
gp7CC      = 82;
hihatLRCC  = 83;
hiresVelCC = 88;


// MIDI note assignments for the ns_kit7 layout
// --------------------------------------------
//
// Cymbals
trigger_cy8_splash  = 1;
trigger_cy9_splash  = 5;
trigger_cy12_splash = 9;
trigger_cy15_crash  = 13;
trigger_cy18_crash  = 17;
trigger_cy19_china  = 21;
trigger_cy20_ride   = 25;
trigger_cy19_ride   = 29;
// Cymbal offsets for zones
zone_cy_bel       = 0;
zone_cy_top_inner = 1;
zone_cy_top_outer = 2;
zone_cy_rim       = 3;

// Trigger maps from sliders - zones from whatever position sensing we get
cy_map = malloc(0, 8);
cy_map[0] = trigger_cy8_splash;
cy_map[1] = trigger_cy9_splash;
cy_map[2] = trigger_cy12_splash;
cy_map[3] = trigger_cy15_crash;
cy_map[4] = trigger_cy18_crash;
cy_map[5] = trigger_cy19_china;
cy_map[6] = trigger_cy20_ride;
cy_map[7] = trigger_cy19_ride;


// Hi-Hat
trigger_hh = 33;
// Hi-Hat offsets for zones
zone_hh_bel   = 0;
zone_hh_top_l = 1;
zone_hh_top_r = 2;
zone_hh_rim_l = 3;
zone_hh_rim_r = 4;
zone_hh_ped   = 5;
zone_hh_spl   = 6;


// Kick
trigger_kick = 40;
// Kick offsets for zones
zone_kick_cls = 0;
zone_kick_opn = 1;


// Snare
trigger_snare = 42;
// Snare offsets for zones
zone_sn_head = 0;
zone_sn_xtk  = 1;
zone_sn_rim  = 2;
zone_sn_rms  = 3;
zone_sn_rmh  = 4;
zone_sn_prs  = 5;
zone_sn_e2c  = 6;
zone_sn_rol  = 7;
// Snare brush mode zones
zone_sn_brush_down_new        = 8;
zone_sn_brush_down_legato     = 9;
zone_sn_brush_down_rls_legato = 10;
zone_sn_brush_drag_new        = 11;
zone_sn_brush_drag_rpt_new    = 12;
zone_sn_brush_drag_legato     = 13;
zone_sn_brush_drag_rpt_legato = 14;
zone_sn_brush_drag_cirular    = 15;
zone_sn_brush_drag_under      = 16;


// Toms
trigger_tm8  = 59;
trigger_tm10 = 64;
trigger_tm12 = 69;
trigger_tm14 = 74;
trigger_tm16 = 79;
// Tom offsets for zones
zone_tm_ord_l = 0;
zone_tm_ord_r = 1;
zone_tm_rim   = 2;
zone_tm_rms_l = 3;
zone_tm_rms_r = 4;

// Trigger maps from sliders - zones from whatever position sensing we get
tom_map = malloc(0, 5);
tom_map[0] = trigger_tm8;
tom_map[1] = trigger_tm10;
tom_map[2] = trigger_tm12;
tom_map[3] = trigger_tm14;
tom_map[4] = trigger_tm16;

// Cowbell
trigger_cowbell = 84;
// Cowbell offsets for zones
zone_cowbell_muted_ord = 0;
zone_cowbell_muted_top = 1;
zone_cowbell_open_ord  = 2;
zone_cowbell_open_top  = 3;

// Tambourine
trigger_tambourine = 88;
// Tambourine offsets for zones
zone_tambourine_hit = 0;
zone_tambourine_jng = 1;
zone_tambourine_rol = 2;
zone_tambourine_thm = 3;

// Trigger maps from sliders - zones from whatever position sensing we get
pn_map = malloc(0, 8);
pn_map[0] = trigger_cowbell + zone_cowbell_muted_ord;
pn_map[1] = trigger_cowbell + zone_cowbell_muted_top;
pn_map[2] = trigger_cowbell + zone_cowbell_open_ord;
pn_map[3] = trigger_cowbell + zone_cowbell_open_top;
pn_map[4] = trigger_tambourine + zone_tambourine_hit;
pn_map[5] = trigger_tambourine + zone_tambourine_jng;
pn_map[6] = trigger_tambourine + zone_tambourine_rol;
pn_map[7] = trigger_tambourine + zone_tambourine_thm;


// MIDI message definitions
// ------------------------
// Channel Voice messages (low half-byte = channel; 0x0 to 0xF = "1" to "16")
noteOff = 0x80; // note No; off velocity
noteOn  = 0x90; // note No; on velocity
polyAft = 0xA0; // note No; note pressure
cc      = 0xB0; // control No (< 0x78); value
pc      = 0xC0; // program No
chanAft = 0xD0; // channel pressure
pb      = 0xE0; // pitch bend: lsb, msb

// Channel Mode messages
cm      = 0xB0; // 3 (>= 0x78)

// System messages
sysex   = 0xF0; // "start of sysex": varies
sysmtcq = 0xF1; // MIDI Time Code Quarter Frame: 0nnndddd; nnn message type, dddd values
sysspp  = 0xF2; // Song Position Pointer: lsb, msb
syssong = 0xF3; // Song Select: num
//        0xF4  -- undefined
//        0xF5  -- undefined
systune = 0xF6; // Tune request
syseox  = 0xF7; // "end of sysex"

// Do we just ignore the incoming MIDI messaage?
passthru = 1;

// Interesting control message values
snareCCVal   = 0;
rideCCVal    = 0;
tomAuxCCVal  = 0;
hihatCCVal   = 0;
gp5CCVal     = 0;
gp6CCVal     = 0;
gp7CCVal     = 0;
hihatLRCCVal = 0;
hiresVelVal  = 0;

// Track note mapping for noteOn so noteOff and polyAft match
// (Set noteMap[note] to ns_kit7 trigger note number plus zone offset on noteOn;
// then use noteMap[note] for noteOff, setting to -1 on noteOff.  Set to -2 to skip.)
noteMap = malloc(-1, 128);

// Track polyphonic aftertouch values on a per-note basis
polyAftVal = malloc(-1, 128);

// Brush state
newBlock = 0;
blocksSinceLastSnareNote = -1;
sentBrushRelease = 0;
sentBrushReleaseOff = 0;
snareCCSinceBrushNote = 1;

// Count blocks since last kick to decide whether to use opn or cls kick note
blocksSinceLastKick = -1;

// Let's say a block is 64 samples at 48KHz, so 64/48000 = 0.001333333 seconds per block, 750 blocks = 1 second.
// srate is samples per second and samplesblock is samples per block
// srate / samplesblock = blocks per second

// Half a second threshold for brush release
brushRate = (srate / samplesblock) / 6;

// Fast kick threshold is 12 a second
kickRate = (srate / samplesblock) / 12;

// Tom R/L toggle as there is no r/l sensing
tomRL = 0;

@block
newBlock = 1;

blocksSinceLastSnareNote >= 0 ? blocksSinceLastSnareNote = blocksSinceLastSnareNote + 1;
dbgBlocksSinceLastSnareNote = blocksSinceLastSnareNote;

sentBrushRelease == 1 && sentBrushReleaseOff == 0 ? (
  sentBrushReleaseOff = 1;
  brushKit && midisend(offset, (0x09 | noteOff) & 0xFF, (trigger_snare + zone_sn_brush_down_rls_legato) & 0x7F, 1);
);
blocksSinceLastSnareNote > (4 * brushRate) ? (
  // brushes stopped
  blocksSinceLastSnareNote = -1;
  sentBrushRelease == 0 ? (
    sentBrushRelease = 1;
    sentBrushReleaseOff = 0;
    brushKit && midisend(offset, (0x09 | noteOn) & 0xFF, (trigger_snare + zone_sn_brush_down_rls_legato) & 0x7F, 1);
  );
);

// Blocks since last kick note.
// This affects the first note in a run, rather than the last note, which is what's really wanted.
blocksSinceLastKick >= 0 ? (
  blocksSinceLastKick = blocksSinceLastKick + 1;
  blocksSinceLastKick > (12 * kickRate) ? (
    blocksSinceLastKick = -1; // reset
  );
);

while (midirecv(offset, msg1, msg2, msg3)) (

  cmd = msg1 & 0xF0;
  passthru = 1;

  // Explicit Note Off and Note On Velocity 0
  ((cmd == noteOff) || ((cmd == noteOn) && (msg3 == 0))) ? (
    noteMap[msg2] >= 0 ? (
      midisend(offset, msg1, noteMap[msg2] & 0x7F, msg3);
      0;
    );
    (noteMap[msg2] != -1) ? passthru = 0;
    dgbNoteOffNote = (noteMap[msg2] < 0) ? msg2 : (noteMap[msg2] & 0x7F);
    dgbNoteOffVal = msg3;


  ) : (cmd == noteOn) ? (
    // Map the note to the ns_kit7 trigger note number plus zone offset
    dgbNoteOnNote = msg2;
    dgbNoteOnVal = msg3;

    // Kick
    (msg2 == noteKick) ? (
      noteMap[msg2] = trigger_kick + (
        blocksSinceLastKick = 0; // start counting if we weren't
        ((blocksSinceLastKick >= 0) && (blocksSinceLastKick < kickRate)) ? (
          zone_kick_cls // cls on fast kicks
        ) : (
          zone_kick_opn // opn on other kicks
        )
      );
    ) :

    // Snare
    // zone_sn_prs = 5; - zone unmapped
    // zone_sn_e2c = 6; - zone unmapped
    // zone_sn_rol = 7; - zone unmapped
    // zone_sn_brush_drag_cirular = 15; - zone unmapped
    // zone_sn_brush_drag_under = 16; - zone unmapped
    ((msg2 == noteSnareHead) || (msg2 == noteSnareBrush)) ? (
      brushKit ? (
        // OK, so we've gone for a simple model:
        // - snareCCSinceBrushNote or timeout - used to trigger "first note"
        // - blocksSinceLastSnareNote >= 3    - used to trigger "subsequent note"
        // - *all* later notes now map to polyAft
        // can make it more complex later
        //
        // -> zone_sn_brush_down_new
        // -> zone_sn_brush_down_legato
        // -> zone_sn_brush_down_rls_legato -- when brush stops moving
        // -> zone_sn_brush_drag_new
        // -> zone_sn_brush_drag_rpt_new
        // -> zone_sn_brush_drag_legato
        // -> zone_sn_brush_drag_rpt_legato

        noteMap[msg2] = trigger_snare + zone_sn_brush_drag_legato;
        (snareCCSinceBrushNote || blocksSinceLastSnareNote == -1) && blocksSinceLastSnareNote <= (3 * brushRate) ? (
          // First brush note since reset so drag new
          noteMap[msg2] = trigger_snare + zone_sn_brush_down_legato;
        );
        (snareCCSinceBrushNote || blocksSinceLastSnareNote == -1) || (newBlock && blocksSinceLastSnareNote > (3 * brushRate)) ? (
          // New note
          snareCCSinceBrushNote = 0;
          blocksSinceLastSnareNote = 0;
          newBlock = 0;
          sentBrushRelease = 0;
        ) : (
          // Send remaining brush notes as polyphonic aftertouch
          newBlock && midisend(offset, ((msg1 & 0x0F) | polyAft) & 0xFF, noteMap[msg2] & 0x7F, (128 - msg3) & 0x7F);
          newBlock = 0;
          // Suppress note on
          noteMap[msg2] = -2;
          passthru = 0;
        );

      ) : (

        noteMap[msg2] = trigger_snare + (snareCCVal < 120
          ? zone_sn_head
          : snareCCVal < 126
            ? zone_sn_rmh
            : zone_sn_rms
          );

      );
    ) :
    (msg2 == noteSnareRim) ? (
      noteMap[msg2] = trigger_snare + (brushKit
        ? zone_sn_rim
        : // Position sensing may not be that reliable but try... no, too poor...
          // snareCCVal == 127
          //  ? zone_sn_rim
          //  : snareCCVal < 64
          //    ? zone_sn_rms
          //    : zone_sn_rmh
          zone_sn_rim
      );
    ) :
    (msg2 == noteSnareXStick) ? (
        noteMap[msg2] = trigger_snare + zone_sn_xtk;
    ) :

    // Toms - no r/l triggering...
    (msg2 == noteTom1Head) ? (
      tomRL = tomRL ? 0 : 1;
      noteMap[msg2] = tom_map[tom1] + ((tomAuxCCVal < 126)
        ? (tomRL ? zone_tm_ord_l : zone_tm_ord_r)
        : (tomRL ? zone_tm_rms_l : zone_tm_rms_r)
      );
    ) :
    (msg2 == noteTom2Head) ? (
      tomRL = tomRL ? 0 : 1;
      noteMap[msg2] = tom_map[tom2] + ((tomAuxCCVal < 126)
        ? (tomRL ? zone_tm_ord_l : zone_tm_ord_r)
        : (tomRL ? zone_tm_rms_l : zone_tm_rms_r)
      );
    ) :
    (msg2 == noteTom3Head) ? (
      tomRL = tomRL ? 0 : 1;
      noteMap[msg2] = tom_map[tom3] + ((tomAuxCCVal < 126)
        ? (tomRL ? zone_tm_ord_l : zone_tm_ord_r)
        : (tomRL ? zone_tm_rms_l : zone_tm_rms_r)
      );
    ) :
    (msg2 == noteTom1Rim) ? (
      noteMap[msg2] = tom_map[tom1] + zone_tm_rim;
    ) :
    (msg2 == noteTom2Rim) ? (
      noteMap[msg2] = tom_map[tom2] + zone_tm_rim;
    ) :
    (msg2 == noteTom3Rim) ? (
      noteMap[msg2] = tom_map[tom3] + zone_tm_rim;
    ) :

    // Hi-Hat
    ((msg2 == noteHiHatOpenBow) || (msg2 == noteHiHatCloseBow)) ? (
      noteMap[msg2] = trigger_hh + (hihatCCVal == 0 ? zone_hh_bel : (hihatLRCCVal < 64 ? zone_hh_top_l : zone_hh_top_r));
    ) :
    ((msg2 == noteHiHatOpenEdge) || (msg2 == noteHiHatCloseEdge)) ? (
      noteMap[msg2] = trigger_hh + (hihatLRCCVal < 64 ? zone_hh_rim_l : zone_hh_rim_r);
    ) :
    (msg2 == noteHiHatPedal) ? (
      noteMap[msg2] = trigger_hh + zone_hh_ped;
    ) :
    (msg2 == noteHiHatSplash) ? (
      noteMap[msg2] = trigger_hh + zone_hh_spl;
    ) :

    // Crash cymbals
    // zone_cy_top_outer = 2; - No position sensing on TD-27 crash cymbals
    (msg2 == noteCrash1Bow) ? (
      noteMap[msg2] = cy_map[crash1] + zone_cy_top_inner;
    ) :
    (msg2 == noteCrash1Edge) ? (
      noteMap[msg2] = cy_map[crash1] + zone_cy_rim;
    ) :
    (msg2 == noteCrash2Bow) ? (
      noteMap[msg2] = cy_map[crash2] + zone_cy_top_inner;
    ) :
    (msg2 == noteCrash2Edge) ? (
      noteMap[msg2] = cy_map[crash2] + zone_cy_rim;
    ) :

    // Ride cymbal
    (msg2 == noteRideBell) ? (
      noteMap[msg2] = cy_map[ride] + zone_cy_bel;
    ) :
    (msg2 == noteRideBow) ? (
      noteMap[msg2] = cy_map[ride] + (rideCCVal < 96 ? zone_cy_top_inner : zone_cy_top_outer);
    ) :
    (msg2 == noteRideEdge) ? (
      noteMap[msg2] = cy_map[ride] + zone_cy_rim;
    ) :

    // Aux "head" and "rim" as separate inputs
    (msg2 == noteAux1Head) ? (
      noteMap[msg2] = pn_map[aux1head];
    ) :
    (msg2 == noteAux1Rim) ? (
      noteMap[msg2] = pn_map[aux1rim];
    ) :
    (msg2 == noteAux2Head) ? (
      noteMap[msg2] = pn_map[aux2head];
    ) :
    (msg2 == noteAux2Rim) ? (
      noteMap[msg2] = pn_map[aux2rim];
    ) :
    (msg2 == noteAux3Head) ? (
      noteMap[msg2] = pn_map[aux3head];
    ) :
    (msg2 == noteAux3Rim) ? (
      noteMap[msg2] = pn_map[aux3rim];
    );

    dbgMappedNote = noteMap[msg2];

    (noteMap[msg2] >= 0) ? (
      // If we have a mapping, send the noteOn with the mapped note number and indicate no passthru
      midisend(offset, msg1, noteMap[msg2] & 0x7F, msg3);
      0;
    );
    noteMap[msg2] != -1 ? passthru = 0;


  ) : (cmd == polyAft) ? (
    noteMap[msg2] >= 0 ? (
      midisend(offset, msg1, noteMap[msg2] & 0x7F, msg3);
      0;
    );
    noteMap[msg2] != -1 ? passthru = 0;
    dgbPolyAftNote = (noteMap[msg2] < 0 ? msg2 : (noteMap[msg2] & 0x7F));
    dgbPolyAftVal = msg3;


  ) : (cmd == cc) ? (
    (msg2 == snareCC) ? (
      snareCCVal = msg3;
      dgbSnareVal = snareCCVal;
      snareCCSinceBrushNote = 1;
      passthru = 0;
    ) :
    (msg2 == rideCC) ? (
      rideCCVal = msg3;
      dgbRideVal = rideCCVal;
      passthru = 0;
    ) :
    (msg2 == tomAuxCC) ? (
      tomAuxCCVal = msg3;
      dgbTomAuxVal = tomAuxCCVal;
      passthru = 0;
    ) :
    (msg2 == hihatCC) ? (
      hihatCCVal = msg3;
      dgbHihatVal = hihatCCVal;
      passthru = 0;
    ) :
    //(msg2 == gp5CC) ? (
    //  gp5CCVal = msg3;
    //  passthru = 0;
    //) :
    //(msg2 == gp6CC) ? (
    //  gp6CCVal = msg3;
    //  passthru = 0;
    //) :
    //(msg2 == gp7CC) ? (
    //  gp7CCVal = msg3;
    //  passthru = 0;
    //) :
    (msg2 == hihatLRCC) ? (
      hihatLRCCVal = msg3;
      dgbHihatLRVal = hihatLRCCVal;
      passthru = 0;
    ) :
    (msg2 == hihatLRCC) ? (
      hiresVelVal  = msg3;
      dgbHiresVelVal = hiresVelCCVal;
      passthru = 0;
    )


  );

  dgbPassthru = passthru;
  passthru ? midisend(offset, msg1, msg2, msg3);

)
